<!DOCTYPE html>
<html lang="en">

<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163094446-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-163094446-1');
	</script>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="basic-api-resource-rule" />
	<meta name="description" content="basic-api-resource-rule" />
	<!-- 网页标签标题 -->
	<title>basic-api-resource-rule</title>
	<link rel="shortcut icon" href="/img/sentinel.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot="" data-reactid="1" data-react-checksum="-100921768"><header class="header-container header-container-normal" data-reactid="2"><div class="header-body" data-reactid="3"><a href="/zh-cn/index.html" data-reactid="4"><img class="logo" src="/img/sentinel_colorful.png" data-reactid="5"/></a><div class="search search-normal" data-reactid="6"><span class="icon-search" data-reactid="7"></span></div><span class="language-switch language-switch-normal" data-reactid="8">En</span><div class="header-menu" data-reactid="9"><img class="header-menu-toggle" src="/img/system/menu_gray.png" data-reactid="10"/><ul data-reactid="11"><li class="menu-item menu-item-normal" data-reactid="12"><span data-reactid="13"><a href="/zh-cn/index.html" data-reactid="14">首页</a></span></li><li class="menu-item menu-item-normal menu-item-normal-active" data-reactid="15"><span data-reactid="16"><a href="/zh-cn/docs/introduction.html" data-reactid="17">文档</a></span></li><li class="menu-item menu-item-normal" data-reactid="18"><div class="nav-container" data-reactid="19"><div class="word" data-reactid="20"><a data-reactid="21">解决方案</a><img class="menu-img" src="https://img.alicdn.com/tfs/TB1esl_m.T1gK0jSZFrXXcNCXXa-200-200.png" data-reactid="22"/></div><ul class="sub-nav-container" style="width:220px;" data-reactid="23"><li data-reactid="24"><a href="https://www.aliyun.com/product/ahas?sentinel-website.topbar.0.0.0" target="_blank" data-reactid="25">高可用解决方案</a></li><li data-reactid="26"><a href="https://cn.aliyun.com/product/aliware/mse?sentinel-website.topbar.0.0.0" target="_blank" data-reactid="27">微服务解决方案</a></li><li data-reactid="28"><a href="https://www.aliyun.com/aliware/txc?sentinel-website.topbar.0.0.0" target="_blank" data-reactid="29">分布式事务解决方案</a></li><li data-reactid="30"><a href="https://cn.aliyun.com/product/aliware/sae?sentinel-website.topbar.0.0.0" target="_blank" data-reactid="31">微服务Serverless解决方案</a></li><li data-reactid="32"><a href="https://www.aliyun.com/product/edas?sentinel-website.topbar.0.0.0" target="_blank" data-reactid="33">APaaS解决方案</a></li><li data-reactid="34"><a href="https://www.aliyun.com/product/servicemesh?sentinel-website.topbar.0.0.0" target="_blank" data-reactid="35">服务网格解决方案</a></li></ul><!-- react-text: 36 --> <!-- /react-text --></div></li><li class="menu-item menu-item-normal" data-reactid="37"><span data-reactid="38"><a href="/zh-cn/docs/developers/developers_dev.html" data-reactid="39">开发者</a></span></li><li class="menu-item menu-item-normal" data-reactid="40"><span data-reactid="41"><a href="/zh-cn/blog/index.html" data-reactid="42">博客</a></span></li><li class="menu-item menu-item-normal" data-reactid="43"><span data-reactid="44"><a href="/zh-cn/community/index.html" data-reactid="45">社区</a></span></li><li class="menu-item menu-item-normal" data-reactid="46"><span data-reactid="47"><a href="https://www.aliyun.com/product/ahas" data-reactid="48">企业版 Sentinel</a><img class="menu-img" src="https://img.alicdn.com/tfs/TB1esl_m.T1gK0jSZFrXXcNCXXa-200-200.png" data-reactid="49"/></span></li></ul></div></div></header><div class="bar" data-reactid="50"><div class="bar-body" data-reactid="51"><img src="/img/system/docs.png" class="front-img" data-reactid="52"/><span data-reactid="53">文档</span><img src="/img/system/docs.png" class="back-img" data-reactid="54"/></div></div><section class="content-section" data-reactid="55"><div class="sidemenu" data-reactid="56"><div class="sidemenu-toggle" data-reactid="57"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png" data-reactid="58"/></div><ul data-reactid="59"><li class="menu-item menu-item-level-1" data-reactid="60"><span data-reactid="61">用户文档</span><ul data-reactid="62"><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="63"><span data-reactid="64"><!-- react-text: 65 -->入门<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/system/arrow_down.png" data-reactid="66"/></span><ul data-reactid="67"><li class="menu-item menu-item-level-3" data-reactid="68"><a href="/zh-cn/docs/introduction.html" target="_self" data-reactid="69">Sentinel 介绍</a></li><li class="menu-item menu-item-level-3" data-reactid="70"><a href="/zh-cn/docs/quick-start.html" target="_self" data-reactid="71">快速开始</a></li><li class="menu-item menu-item-level-3" data-reactid="72"><a href="/zh-cn/docs/basic-implementation.html" target="_self" data-reactid="73">基本原理</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="74"><a href="/zh-cn/docs/faq.html" target="_self" data-reactid="75">FAQ</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="76"><span data-reactid="77"><!-- react-text: 78 -->使用文档<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/system/arrow_down.png" data-reactid="79"/></span><ul data-reactid="80"><li class="menu-item menu-item-level-3" data-reactid="81"><a href="/zh-cn/docs/basic-api-resource-rule.html" target="_self" data-reactid="82">基本使用（资源与规则）</a></li><li class="menu-item menu-item-level-3" data-reactid="83"><a href="/zh-cn/docs/flow-control.html" target="_self" data-reactid="84">流量控制</a></li><li class="menu-item menu-item-level-3" data-reactid="85"><a href="/zh-cn/docs/circuit-breaking.html" target="_self" data-reactid="86">熔断降级</a></li><li class="menu-item menu-item-level-3" data-reactid="87"><a href="/zh-cn/docs/system-adaptive-protection.html" target="_self" data-reactid="88">系统自适应保护</a></li><li class="menu-item menu-item-level-3" data-reactid="89"><a href="/zh-cn/docs/cluster-flow-control.html" target="_self" data-reactid="90">集群流量控制</a></li><li class="menu-item menu-item-level-3" data-reactid="91"><a href="/zh-cn/docs/api-gateway-flow-control.html" target="_self" data-reactid="92">网关流量控制</a></li><li class="menu-item menu-item-level-3" data-reactid="93"><a href="/zh-cn/docs/parameter-flow-control.html" target="_self" data-reactid="94">热点参数限流</a></li><li class="menu-item menu-item-level-3" data-reactid="95"><a href="/zh-cn/docs/origin-authority-control.html" target="_self" data-reactid="96">来源访问控制</a></li><li class="menu-item menu-item-level-3" data-reactid="97"><a href="/zh-cn/docs/annotation-support.html" target="_self" data-reactid="98">注解支持</a></li><li class="menu-item menu-item-level-3" data-reactid="99"><a href="/zh-cn/docs/dynamic-rule-configuration.html" target="_self" data-reactid="100">动态规则扩展</a></li><li class="menu-item menu-item-level-3" data-reactid="101"><a href="/zh-cn/docs/logs.html" target="_self" data-reactid="102">日志</a></li><li class="menu-item menu-item-level-3" data-reactid="103"><a href="/zh-cn/docs/metrics.html" target="_self" data-reactid="104">实时监控</a></li><li class="menu-item menu-item-level-3" data-reactid="105"><a href="/zh-cn/docs/general-configuration.html" target="_self" data-reactid="106">启动配置项</a></li></ul></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="107"><a href="/zh-cn/docs/dashboard.html" target="_self" data-reactid="108">Sentinel 控制台</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="109"><a href="/zh-cn/docs/open-source-framework-integrations.html" target="_self" data-reactid="110">开源框架适配</a></li><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="111"><a href="/zh-cn/docs/polyglot-support.html" target="_self" data-reactid="112">多语言支持</a></li></ul></li><li class="menu-item menu-item-level-1" data-reactid="113"><span data-reactid="114">多语言文档</span><ul data-reactid="115"><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="116"><span data-reactid="117"><!-- react-text: 118 -->Sentinel Go<!-- /react-text --><img style="transform:rotate(-90deg);" class="menu-toggle" src="/img/system/arrow_down.png" data-reactid="119"/></span><ul data-reactid="120"><li class="menu-item menu-item-level-3" data-reactid="121"><a href="/zh-cn/docs/golang/basic-api-usage.html" target="_self" data-reactid="122">基本 API 使用指南</a></li><li class="menu-item menu-item-level-3" data-reactid="123"><a href="/zh-cn/docs/golang/flow-control.html" target="_self" data-reactid="124">流量控制</a></li><li class="menu-item menu-item-level-3" data-reactid="125"><a href="/zh-cn/docs/golang/circuit-breaking.html" target="_self" data-reactid="126">熔断降级</a></li><li class="menu-item menu-item-level-3" data-reactid="127"><a href="/zh-cn/docs/golang/concurrency-limiting-isolation.html" target="_self" data-reactid="128">并发隔离控制</a></li><li class="menu-item menu-item-level-3" data-reactid="129"><a href="/zh-cn/docs/golang/system-adaptive-protection.html" target="_self" data-reactid="130">系统自适应保护</a></li><li class="menu-item menu-item-level-3" data-reactid="131"><a href="/zh-cn/docs/golang/hotspot-param-flow-control.html" target="_self" data-reactid="132">热点参数流控</a></li><li class="menu-item menu-item-level-3" data-reactid="133"><a href="/zh-cn/docs/golang/dynamic-data-source-usage.html" target="_self" data-reactid="134">动态规则扩展</a></li><li class="menu-item menu-item-level-3" data-reactid="135"><a href="/zh-cn/docs/golang/general-configuration.html" target="_self" data-reactid="136">通用配置</a></li><li class="menu-item menu-item-level-3" data-reactid="137"><a href="/zh-cn/docs/golang/logging.html" target="_self" data-reactid="138">日志</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1" data-reactid="139"><span data-reactid="140">贡献手册</span><ul data-reactid="141"><li style="height:36px;overflow:hidden;" class="menu-item menu-item-level-2" data-reactid="142"><a href="/zh-cn/docs/contribution/contribution-guideline.html" target="_self" data-reactid="143">开源贡献指南</a></li></ul></li></ul></div><div class="doc-content markdown-body" data-reactid="144"><h1>基本使用 - 资源与规则</h1>
<h2>简介</h2>
<p>Sentinel 可以简单的分为 Sentinel 核心库和 Dashboard。核心库不依赖 Dashboard，但是结合 Dashboard 可以取得最好的效果。</p>
<p>这篇文章主要介绍 Sentinel 核心库的使用。如果希望有一个最快最直接的了解，可以参考 <a href="./quick-start.md">新手指南</a> 来获取一个最直观的感受。</p>
<p>我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为几个步骤:</p>
<ol>
<li>定义资源</li>
<li>定义规则</li>
<li>检验规则是否生效</li>
</ol>
<p>先把可能需要保护的资源定义好，之后再配置规则。也可以理解为，只要有了资源，我们就可以在任何时候灵活地定义各种流量控制规则。在编码的时候，只需要考虑这个代码是否需要保护，如果需要保护，就将之定义为一个资源。</p>
<p>对于主流的框架，我们提供适配，只需要按照适配中的说明配置，Sentinel 就会默认定义提供的服务，方法等为资源。</p>
<h2>定义资源</h2>
<h3>方式一：主流框架的默认适配</h3>
<p>为了减少开发的复杂程度，我们对大部分的主流框架，例如 Web Servlet、Dubbo、Spring Cloud、gRPC、Spring WebFlux、Reactor 等都做了适配。您只需要引入对应的依赖即可方便地整合 Sentinel。可以参见：<a href="./open-source-framework-integrations.md">主流框架的适配</a>。</p>
<h3>方式二：抛出异常的方式定义资源</h3>
<p><code>SphU</code> 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 <code>BlockException</code>。这个时候可以捕捉异常，进行限流之后的逻辑处理。示例代码如下:</p>
<pre><code class="language-java"><span class="hljs-comment">// 1.5.0 版本开始可以利用 try-with-resources 特性</span>
<span class="hljs-comment">// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span>
<span class="hljs-keyword">try</span> (Entry entry = SphU.entry(<span class="hljs-string">"resourceName"</span>)) {
  <span class="hljs-comment">// 被保护的业务逻辑</span>
  <span class="hljs-comment">// do something here...</span>
} <span class="hljs-keyword">catch</span> (BlockException ex) {
  <span class="hljs-comment">// 资源访问阻止，被限流或被降级</span>
  <span class="hljs-comment">// 在此处进行相应的处理操作</span>
}
</code></pre>
<p><strong>特别地</strong>，若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。这个时候不能使用 try-with-resources 的方式。另外通过 <code>Tracer.trace(ex)</code> 来统计异常信息时，由于 try-with-resources 语法中 catch 调用顺序的问题，会导致无法正确统计异常数，因此统计异常信息时也不能在 try-with-resources 的 catch 块中调用 <code>Tracer.trace(ex)</code>。</p>
<p>1.5.0 之前的版本的示例：</p>
<pre><code class="language-java">Entry entry = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">// 务必保证finally会被执行</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-comment">// 资源名可使用任意有业务语义的字符串</span>
  entry = SphU.entry(<span class="hljs-string">"自定义资源名"</span>);
  <span class="hljs-comment">// 被保护的业务逻辑</span>
  <span class="hljs-comment">// do something...</span>
} <span class="hljs-keyword">catch</span> (BlockException e1) {
  <span class="hljs-comment">// 资源访问阻止，被限流或被降级</span>
  <span class="hljs-comment">// 进行相应的处理操作</span>
} <span class="hljs-keyword">finally</span> {
  <span class="hljs-keyword">if</span> (entry != <span class="hljs-keyword">null</span>) {
    entry.exit();
  }
}
</code></pre>
<p><strong>注意：</strong> <code>SphU.entry(xxx)</code> 需要与 <code>entry.exit()</code> 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 <code>ErrorEntryFreeException</code> 异常。</p>
<h3>方式三：返回布尔值方式定义资源</h3>
<p><code>SphO</code> 提供 if-else 风格的 API。用这种方式，当资源发生了限流之后会返回 <code>false</code>，这个时候可以根据返回值，进行限流之后的逻辑处理。示例代码如下:</p>
<pre><code class="language-java">  <span class="hljs-comment">// 资源名可使用任意有业务语义的字符串</span>
  <span class="hljs-keyword">if</span> (SphO.entry(<span class="hljs-string">"自定义资源名"</span>)) {
    <span class="hljs-comment">// 务必保证finally会被执行</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">/**
      * 被保护的业务逻辑
      */</span>
    } <span class="hljs-keyword">finally</span> {
      SphO.exit();
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 资源访问阻止，被限流或被降级</span>
    <span class="hljs-comment">// 进行相应的处理操作</span>
  }
</code></pre>
<h3>方式四：注解方式定义资源</h3>
<p>Sentinel 支持通过 <code>@SentinelResource</code> 注解定义资源并配置 <code>blockHandler</code> 和 <code>fallback</code> 函数来进行限流之后的处理。示例：</p>
<pre><code class="language-java"><span class="hljs-comment">// 原本的业务方法.</span>
<span class="hljs-meta">@SentinelResource</span>(blockHandler = <span class="hljs-string">"blockHandlerForGetUser"</span>)
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserById</span><span class="hljs-params">(String id)</span> </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"getUserById command failed"</span>);
}

<span class="hljs-comment">// blockHandler 函数，原方法调用被限流/降级/系统保护的时候调用</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">blockHandlerForGetUser</span><span class="hljs-params">(String id, BlockException ex)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-string">"admin"</span>);
}
</code></pre>
<p>注意 <code>blockHandler</code> 函数会在原方法被限流/降级/系统保护的时候调用，而 <code>fallback</code> 函数会针对所有类型的异常。请注意 <code>blockHandler</code> 和 <code>fallback</code> 函数的形式要求，更多指引可以参见 <a href="./annotation-support.md">Sentinel 注解支持文档</a>。</p>
<h3>方式五：异步调用支持</h3>
<p>Sentinel 支持异步调用链路的统计。在异步调用中，需要通过 <code>SphU.asyncEntry(xxx)</code> 方法定义资源，并通常需要在异步的回调函数中调用 <code>exit</code> 方法。以下是一个简单的示例：</p>
<pre><code class="language-java"><span class="hljs-keyword">try</span> {
    AsyncEntry entry = SphU.asyncEntry(resourceName);

    <span class="hljs-comment">// 异步调用.</span>
    doAsync(userId, result -&gt; {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 在此处处理异步调用的结果.</span>
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 在回调结束后 exit.</span>
            entry.exit();
        }
    });
} <span class="hljs-keyword">catch</span> (BlockException ex) {
    <span class="hljs-comment">// Request blocked.</span>
    <span class="hljs-comment">// Handle the exception (e.g. retry or fallback).</span>
}
</code></pre>
<p><code>SphU.asyncEntry(xxx)</code> 不会影响当前（调用线程）的 Context，因此以下两个 entry 在调用链上是平级关系（处于同一层），而不是嵌套关系：</p>
<pre><code class="language-java"><span class="hljs-comment">// 调用链类似于：</span>
<span class="hljs-comment">// -parent</span>
<span class="hljs-comment">// ---asyncResource</span>
<span class="hljs-comment">// ---syncResource</span>
asyncEntry = SphU.asyncEntry(asyncResource);
entry = SphU.entry(normalResource);
</code></pre>
<p>若在异步回调中需要嵌套其它的资源调用（无论是 <code>entry</code> 还是 <code>asyncEntry</code>），只需要借助 Sentinel 提供的上下文切换功能，在对应的地方通过 <code>ContextUtil.runOnContext(context, f)</code> 进行 Context 变换，将对应资源调用处的 Context 切换为生成的异步 Context，即可维持正确的调用链路关系。示例如下：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResult</span><span class="hljs-params">(String result)</span> </span>{
    Entry entry = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">try</span> {
        entry = SphU.entry(<span class="hljs-string">"handleResultForAsync"</span>);
        <span class="hljs-comment">// Handle your result here.</span>
    } <span class="hljs-keyword">catch</span> (BlockException ex) {
        <span class="hljs-comment">// Blocked for the result handler.</span>
    } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (entry != <span class="hljs-keyword">null</span>) {
            entry.exit();
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someAsync</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        AsyncEntry entry = SphU.asyncEntry(resourceName);

        <span class="hljs-comment">// Asynchronous invocation.</span>
        doAsync(userId, result -&gt; {
            <span class="hljs-comment">// 在异步回调中进行上下文变换，通过 AsyncEntry 的 getAsyncContext 方法获取异步 Context</span>
            ContextUtil.runOnContext(entry.getAsyncContext(), () -&gt; {
                <span class="hljs-keyword">try</span> {
                    <span class="hljs-comment">// 此处嵌套正常的资源调用.</span>
                    handleResult(result);
                } <span class="hljs-keyword">finally</span> {
                    entry.exit();
                }
            });
        });
    } <span class="hljs-keyword">catch</span> (BlockException ex) {
        <span class="hljs-comment">// Request blocked.</span>
        <span class="hljs-comment">// Handle the exception (e.g. retry or fallback).</span>
    }
}
</code></pre>
<p>此时的调用链就类似于：</p>
<pre><code>-parent
---asyncInvocation
-----handleResultForAsync
</code></pre>
<p>更详细的示例可以参考 Demo 中的 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/AsyncEntryDemo.java">AsyncEntryDemo</a>，里面包含了普通资源与异步资源之间的各种嵌套示例。</p>
<h2>规则的种类</h2>
<p>Sentinel 的所有规则都可以在内存态中动态地查询及修改，修改之后立即生效。同时 Sentinel 也提供相关 API，供您来定制自己的规则策略。</p>
<p>Sentinel 支持以下几种规则：<strong>流量控制规则</strong>、<strong>熔断降级规则</strong>、<strong>系统保护规则</strong>、<strong>来源访问控制规则</strong> 和 <strong>热点参数规则</strong>。</p>
<h3>流量控制规则 (FlowRule)</h3>
<h4>流量规则的定义</h4>
<p>重要属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Field</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">resource</td>
<td style="text-align:left">资源名，资源名是限流规则的作用对象</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:left">限流阈值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">grade</td>
<td style="text-align:left">限流阈值类型，QPS 或线程数模式</td>
<td style="text-align:left">QPS 模式</td>
</tr>
<tr>
<td style="text-align:center">limitApp</td>
<td style="text-align:left">流控针对的调用来源</td>
<td style="text-align:left"><code>default</code>，代表不区分调用来源</td>
</tr>
<tr>
<td style="text-align:center">strategy</td>
<td style="text-align:left">调用关系限流策略：直接、链路、关联</td>
<td style="text-align:left">根据资源本身（直接）</td>
</tr>
<tr>
<td style="text-align:center">controlBehavior</td>
<td style="text-align:left">流控效果（直接拒绝 / 排队等待 / 慢启动模式），不支持按调用关系限流</td>
<td style="text-align:left">直接拒绝</td>
</tr>
</tbody>
</table>
<p>同一个资源可以同时有多个限流规则。</p>
<h4>通过代码定义流量控制规则</h4>
<p>理解上面规则的定义之后，我们可以通过调用 <code>FlowRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则，比如：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFlowQpsRule</span><span class="hljs-params">()</span> </span>{
    List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    FlowRule rule1 = <span class="hljs-keyword">new</span> FlowRule();
    rule1.setResource(resource);
    <span class="hljs-comment">// Set max qps to 20</span>
    rule1.setCount(<span class="hljs-number">20</span>);
    rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);
    rule1.setLimitApp(<span class="hljs-string">"default"</span>);
    rules.add(rule1);
    FlowRuleManager.loadRules(rules);
}
</code></pre>
<p>更多详细内容可以参考 <a href="./flow-control.md">流量控制</a>。</p>
<h3>熔断降级规则 (DegradeRule)</h3>
<p>熔断降级规则包含下面几个重要的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Field</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">resource</td>
<td style="text-align:left">资源名，即规则的作用对象</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">grade</td>
<td style="text-align:left">熔断策略，支持慢调用比例/异常比例/异常数策略</td>
<td style="text-align:left">慢调用比例</td>
</tr>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:left">慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">timeWindow</td>
<td style="text-align:left">熔断时长，单位为 s</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">minRequestAmount</td>
<td style="text-align:left">熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:center">statIntervalMs</td>
<td style="text-align:left">统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td>
<td style="text-align:left">1000 ms</td>
</tr>
<tr>
<td style="text-align:center">slowRatioThreshold</td>
<td style="text-align:left">慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>同一个资源可以同时有多个降级规则。</p>
<p>理解上面规则的定义之后，我们可以通过调用 <code>DegradeRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则。</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initDegradeRule</span><span class="hljs-params">()</span> </span>{
    List&lt;DegradeRule&gt; rules = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    DegradeRule rule = <span class="hljs-keyword">new</span> DegradeRule(resource);
        .setGrade(CircuitBreakerStrategy.ERROR_RATIO.getType());
        .setCount(<span class="hljs-number">0.7</span>); <span class="hljs-comment">// Threshold is 70% error ratio</span>
        .setMinRequestAmount(<span class="hljs-number">100</span>)
        .setStatIntervalMs(<span class="hljs-number">30000</span>) <span class="hljs-comment">// 30s</span>
        .setTimeWindow(<span class="hljs-number">10</span>);
    rules.add(rule);
    DegradeRuleManager.loadRules(rules);
}
</code></pre>
<p>更多详情可以参考 <a href="./circuit-breaking.md">熔断降级</a>。</p>
<h3>系统保护规则 (SystemRule)</h3>
<p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p>
<p>系统规则包含下面几个重要的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Field</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">highestSystemLoad</td>
<td style="text-align:left"><code>load1</code> 触发值，用于触发自适应控制阶段</td>
<td style="text-align:left">-1 (不生效)</td>
</tr>
<tr>
<td style="text-align:center">avgRt</td>
<td style="text-align:left">所有入口流量的平均响应时间</td>
<td style="text-align:left">-1 (不生效)</td>
</tr>
<tr>
<td style="text-align:center">maxThread</td>
<td style="text-align:left">入口流量的最大并发数</td>
<td style="text-align:left">-1 (不生效)</td>
</tr>
<tr>
<td style="text-align:center">qps</td>
<td style="text-align:left">所有入口资源的 QPS</td>
<td style="text-align:left">-1 (不生效)</td>
</tr>
<tr>
<td style="text-align:center">highestCpuUsage</td>
<td style="text-align:left">当前系统的 CPU 使用率（0.0-1.0）</td>
<td style="text-align:left">-1 (不生效)</td>
</tr>
</tbody>
</table>
<p>理解上面规则的定义之后，我们可以通过调用 <code>SystemRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSystemProtectionRule</span><span class="hljs-params">()</span> </span>{
  List&lt;SystemRule&gt; rules = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
  SystemRule rule = <span class="hljs-keyword">new</span> SystemRule();
  rule.setHighestSystemLoad(<span class="hljs-number">10</span>);
  rules.add(rule);
  SystemRuleManager.loadRules(rules);
}
</code></pre>
<p>更多详情可以参考 <a href="./system-adaptive-protection.md">系统自适应保护</a>。</p>
<h3>访问控制规则 (AuthorityRule)</h3>
<p>很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的访问控制（黑白名单）的功能。黑白名单根据资源的请求来源（<code>origin</code>）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p>
<p>授权规则，即黑白名单规则（<code>AuthorityRule</code>）非常简单，主要有以下配置项：</p>
<ul>
<li><code>resource</code>：资源名，即限流规则的作用对象</li>
<li><code>limitApp</code>：对应的黑名单/白名单，不同 origin 用 <code>,</code> 分隔，如 <code>appA,appB</code></li>
<li><code>strategy</code>：限制模式，<code>AUTHORITY_WHITE</code> 为白名单模式，<code>AUTHORITY_BLACK</code> 为黑名单模式，默认为白名单模式</li>
</ul>
<p>更多详情可以参考 <a href="origin-authority-control.md">来源访问控制</a>。</p>
<h3>热点规则 (ParamFlowRule)</h3>
<p>详情可以参考 <a href="./parameter-flow-control.md">热点参数限流</a>。</p>
<h2>查询更改规则</h2>
<p>引入了 transport 模块后，可以通过以下的 HTTP API 来获取所有已加载的规则：</p>
<pre><code>http://localhost:8719/getRules?type=&lt;XXXX&gt;
</code></pre>
<p>其中，<code>type=flow</code> 以 JSON 格式返回现有的限流规则，degrade 返回现有生效的降级规则列表，system 则返回系统保护规则。</p>
<p>获取所有热点规则：</p>
<pre><code>http://localhost:8719/getParamRules
</code></pre>
<p>其中，type 可以输入 <code>flow</code>、<code>degrade</code> 等方式来制定更改的规则种类，<code>data</code> 则是对应的 JSON 格式的规则。</p>
<h2>定制自己的持久化规则</h2>
<p>上面的规则配置，都是存在内存中的。即如果应用重启，这个规则就会失效。因此我们提供了开放的接口，您可以通过实现 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AbstractDataSource.java"><code>DataSource</code></a> 接口的方式，来自定义规则的存储数据源。通常我们的建议有：</p>
<ul>
<li>整合动态配置系统，如 ZooKeeper、<a href="https://github.com/alibaba/Nacos">Nacos</a> 等，动态地实时刷新配置规则</li>
<li>结合 RDBMS、NoSQL、VCS 等来实现该规则</li>
<li>配合 Sentinel Dashboard 使用</li>
</ul>
<p>更多详情请参考 <a href="./dynamic-rule-configuration.md">动态规则配置</a>。</p>
<h2>规则生效的效果</h2>
<h3>判断限流降级异常</h3>
<p>通过以下方法判断是否为 Sentinel 的流控降级异常：</p>
<pre><code class="language-java">BlockException.isBlockException(Throwable t);
</code></pre>
<p>除了在业务代码逻辑上看到规则生效，我们也可以通过下面简单的方法，来校验规则生效的效果：</p>
<ul>
<li><strong>暴露的 HTTP 接口</strong>：通过运行下面命令 <code>curl http://localhost:8719/cnode?id=&lt;资源名称&gt;</code>，观察返回的数据。如果规则生效，在返回的数据栏中的 <code>block</code> 以及 <code>block(m)</code> 中会有显示</li>
<li><strong>日志</strong>：Sentinel 提供秒级的资源运行日志以及限流日志，详情可以参考 <a href="./logs.md">日志文档</a></li>
</ul>
<h3>block 事件</h3>
<p>Sentinel 提供以下扩展接口，可以通过 <code>StatisticSlotCallbackRegistry</code> 向 <code>StatisticSlot</code> 注册回调函数：</p>
<ul>
<li><code>ProcessorSlotEntryCallback</code>: callback when resource entry passed (<code>onPass</code>) or blocked (<code>onBlocked</code>)</li>
<li><code>ProcessorSlotExitCallback</code>: callback when resource entry successfully completed (<code>onExit</code>)</li>
</ul>
<p>可以利用这些回调接口来实现报警等功能，实时的监控信息可以从 <code>ClusterNode</code> 中实时获取。</p>
<h2>其它 API</h2>
<h3>业务异常统计 Tracer</h3>
<p>业务异常记录类 <code>Tracer</code> 用于记录业务异常。相关方法：</p>
<ul>
<li><code>trace(Throwable e)</code>：记录业务异常（非 <code>BlockException</code> 异常），对应的资源为当前线程 context 下 entry 对应的资源。</li>
<li><code>trace(Throwable e, int count)</code>：记录业务异常（非 <code>BlockException</code> 异常），异常数目为传入的 <code>count</code>。</li>
<li><code>traceEntry(Throwable, int, Entry)</code>：向传入 entry 对应的资源记录业务异常（非 <code>BlockException</code> 异常），异常数目为传入的 <code>count</code>。</li>
</ul>
<p>如果用户通过 <code>SphU</code> 或 <code>SphO</code> 手动定义资源，则 Sentinel 不能感知上层业务的异常，需要手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常，否则对应的异常不会统计到 Sentinel 异常计数中。注意不要在 try-with-resources 形式的 <code>SphU.entry(xxx)</code> 中使用，否则会统计不上。</p>
<p>从 1.3.1 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。Sentinel 1.3.1 以前的版本需要手动记录。</p>
<h3>上下文工具类 ContextUtil</h3>
<p>相关静态方法：</p>
<p><strong>标识进入调用链入口（上下文）</strong>：</p>
<p>以下静态方法用于标识调用链路入口，用于区分不同的调用链路：</p>
<ul>
<li><code>public static Context enter(String contextName)</code></li>
<li><code>public static Context enter(String contextName, String origin)</code></li>
</ul>
<p>其中 <code>contextName</code> 代表调用链路入口名称（上下文名称），<code>origin</code> 代表调用来源名称。默认调用来源为空。返回值类型为 <code>Context</code>，即生成的调用链路上下文对象。</p>
<p><strong>注意</strong>：<code>ContextUtil.enter(xxx)</code> 方法仅在调用链路入口处生效，即仅在当前线程的初次调用生效，后面再调用不会覆盖当前线程的调用链路，直到 exit。<code>Context</code> 存于 ThreadLocal 中，因此切换线程时可能会丢掉，如果需要跨线程使用可以结合 <code>runOnContext</code> 方法使用。</p>
<p>流控规则中若选择“流控方式”为“链路”方式，则入口资源名即为上面的 <code>contextName</code>。</p>
<p><strong>退出调用链（清空上下文）</strong>：</p>
<ul>
<li><code>public static void exit()</code>：该方法用于退出调用链，清理当前线程的上下文。</li>
</ul>
<p><strong>获取当前线程的调用链上下文</strong>：</p>
<ul>
<li><code>public static Context getContext()</code>：获取当前线程的调用链路上下文对象。</li>
</ul>
<p><strong>在某个调用链上下文中执行代码</strong>：</p>
<ul>
<li><code>public static void runOnContext(Context context, Runnable f)</code>：常用于异步调用链路中 context 的变换。</li>
</ul>
<h3>指标统计配置</h3>
<p>Sentinel 底层采用高性能的滑动窗口数据结构来统计实时的秒级指标数据，并支持对滑动窗口进行配置。主要有以下两个配置：</p>
<ul>
<li><code>windowIntervalMs</code>：滑动窗口的总的时间长度，默认为 1000 ms</li>
<li><code>sampleCount</code>：滑动窗口划分的格子数目，默认为 2；格子越多则精度越高，但是内存占用也会越多</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/9434884/51955215-0af7c500-247e-11e9-8895-9fc0e4c10c8c.png" alt="sliding-window-leap-array"></p>
<p>我们可以通过 <code>SampleCountProperty</code> 来动态地变更滑动窗口的格子数目，通过 <code>IntervalProperty</code> 来动态地变更滑动窗口的总时间长度。注意这两个配置都是<strong>全局生效</strong>的，会影响所有资源的所有指标统计。</p>
<h2>Dashboard</h2>
<p>详情请参考：<a href="./dashboard.md">Sentinel Dashboard 文档</a>。</p>
</div></section><footer class="footer-container" data-reactid="145"><div class="footer-body" data-reactid="146"><img src="/img/sentinel_gray.png" data-reactid="147"/><div class="cols-container" data-reactid="148"><div class="col col-12" data-reactid="149"><h3 data-reactid="150">Disclaimer</h3><p data-reactid="151">Sentinel is an open-source project under Apache License 2.0.</p></div><div class="col col-6" data-reactid="152"><dl data-reactid="153"><dt data-reactid="154">文档</dt><dd data-reactid="155"><a href="/zh-cn/docs/introduction.html" target="_self" data-reactid="156">概览</a></dd><dd data-reactid="157"><a href="/zh-cn/docs/quick-start.html" target="_self" data-reactid="158">快速开始</a></dd><dd data-reactid="159"><a href="/zh-cn/docs/contribution/contribution-guideline.html" target="_self" data-reactid="160">开发者指南</a></dd></dl></div><div class="col col-6" data-reactid="161"><dl data-reactid="162"><dt data-reactid="163">资源</dt><dd data-reactid="164"><a href="/zh-cn/blog/index.html" target="_self" data-reactid="165">博客</a></dd><dd data-reactid="166"><a href="/zh-cn/community/index.html" target="_self" data-reactid="167">社区</a></dd></dl></div></div><div class="copyright" data-reactid="168"><span data-reactid="169">Copyright © 2018 - 2020 The Sentinel Authors | An Alibaba Middleware (Aliware) Project</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>