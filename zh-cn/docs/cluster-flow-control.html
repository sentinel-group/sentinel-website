<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="cluster-flow-control" />
	<meta name="description" content="cluster-flow-control" />
	<!-- 网页标签标题 -->
	<title>cluster-flow-control</title>
	<link rel="shortcut icon" href="/img/sentinel.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/sentinel_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/introduction.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/introduction.html" target="_self">Sentinel 介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/quick-start.html" target="_self">快速开始</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/basic-implementation.html" target="_self">基本原理</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/FAQ.html" target="_self">FAQ</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>使用文档<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/basic-api-resource-rule.html" target="_self">基本使用（资源与规则）</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/flow-control.html" target="_self">流量控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/circuit-breaking.html" target="_self">熔断降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/system-adaptive-protection.html" target="_self">系统自适应保护</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/cluster-flow-control.html" target="_self">集群流量控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/parameter-flow-control.html" target="_self">热点参数限流</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/origin-authority-control.html" target="_self">来源访问控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/annotation-support.html" target="_self">注解支持</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dynamic-rule-configuration.html" target="_self">动态规则扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/logs.html" target="_self">日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/metrics.html" target="_self">实时监控</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/startup-configuration.html" target="_self">启动配置项</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dashboard.html" target="_self">Sentinel 控制台</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/open-source-framework-integrations.html" target="_self">开源框架适配</a></li></ul></li><li class="menu-item menu-item-level-1"><span>贡献手册</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/contribution/contribution-guideline.html" target="_self">开源贡献指南</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>集群流量控制</h1>
<h2>目录</h2>
<ul>
<li>集群流量控制介绍</li>
<li>集群限流（普通模式）</li>
<li>集群限流（热点模式）</li>
<li><a href="#%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99">集群流控规则配置</a></li>
<li><a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%88%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%E7%AE%A1%E7%90%86%EF%BC%89">集群流控管理（控制台）</a></li>
</ul>
<h2>介绍</h2>
<p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p>
<p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p>
<p>集群流控中共有两种身份：</p>
<ul>
<li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li>
<li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li>
</ul>
<h2>模块结构</h2>
<p>Sentinel 1.4.0 开始引入了集群流控模块，主要包含以下几部分：</p>
<ul>
<li><code>sentinel-cluster-common-default</code>: 公共模块，包含公共接口和实体</li>
<li><code>sentinel-cluster-client-default</code>: 默认集群流控 client 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展</li>
<li><code>sentinel-cluster-server-default</code>: 默认集群流控 server 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展；同时提供扩展接口对接规则判断的具体实现（<code>TokenService</code>），默认实现是复用 <code>sentinel-core</code> 的相关逻辑</li>
</ul>
<blockquote>
<p>注意：集群流控模块要求 JDK 版本最低为 1.7。</p>
</blockquote>
<h2>集群流控规则</h2>
<h3>规则</h3>
<p><code>FlowRule</code> 添加了两个字段用于集群限流相关配置：</p>
<pre><code class="language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> clusterMode; <span class="hljs-comment">// 标识是否为集群限流配置</span>
<span class="hljs-keyword">private</span> ClusterFlowConfig clusterConfig; <span class="hljs-comment">// 集群限流相关配置项</span>
</code></pre>
<p>其中 用一个专门的 <code>ClusterFlowConfig</code> 代表集群限流相关配置项，以与现有规则配置项分开：</p>
<pre><code class="language-java"><span class="hljs-comment">// 全局唯一的规则 ID，由集群限流管控端分配.</span>
<span class="hljs-keyword">private</span> Long flowId;

<span class="hljs-comment">// 阈值模式，默认（0）为单机均摊，1 为全局阈值.</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> thresholdType = ClusterRuleConstant.FLOW_THRESHOLD_AVG_LOCAL;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> strategy = ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL;

<span class="hljs-comment">// 在 client 连接失败或通信失败时，是否退化到本地的限流模式</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> fallbackToLocalWhenFail = <span class="hljs-keyword">true</span>;
</code></pre>
<ul>
<li><code>flowId</code> 代表全局唯一的规则 ID，Sentinel 集群限流服务端通过此 ID 来区分各个规则，因此<strong>务必保持全局唯一</strong>。一般 flowId 由统一的管控端进行分配，或写入至 DB 时生成。</li>
<li><code>thresholdType</code> 代表集群限流阈值模式。其中<strong>单机均摊模式</strong>下配置的阈值等同于单机能够承受的限额，token server 会根据客户端对应的 namespace（默认为 <code>project.name</code> 定义的应用名）下的连接数来计算总的阈值（比如独立模式下有 3 个 client 连接到了 token server，然后配的单机均摊阈值为 10，则计算出的集群总量就为 30）；而全局模式下配置的阈值等同于<strong>整个集群的总阈值</strong>。</li>
</ul>
<p><code>ParamFlowRule</code> 热点参数限流相关的集群配置与 <code>FlowRule</code> 相似。</p>
<h3>配置方式</h3>
<p>在集群流控的场景下，我们推荐使用动态规则源来动态地管理规则。</p>
<p>对于客户端，我们可以按照<a href="https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95">原有的方式</a>来向 <code>FlowRuleManager</code> 和 <code>ParamFlowRuleManager</code> 注册动态规则源，例如：</p>
<pre><code class="language-java">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class="hljs-keyword">new</span> NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId, parser);
FlowRuleManager.register2Property(flowRuleDataSource.getProperty());
</code></pre>
<p>对于集群流控 token server，由于集群限流服务端有作用域（namespace）的概念，因此我们需要注册一个自动根据 namespace 生成动态规则源的 PropertySupplier:</p>
<pre><code class="language-java"><span class="hljs-comment">// Supplier 类型：接受 namespace，返回生成的动态规则源，类型为 SentinelProperty&lt;List&lt;FlowRule&gt;&gt;</span>
<span class="hljs-comment">// ClusterFlowRuleManager 针对集群限流规则，ClusterParamFlowRuleManager 针对集群热点规则，配置方式类似</span>
ClusterFlowRuleManager.setPropertySupplier(namespace -&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SomeDataSource(namespace).getProperty();
});
</code></pre>
<p>然后每当集群限流服务端 namespace set 产生变更时，Sentinel 会自动针对新加入的 namespace 生成动态规则源并进行自动监听，并删除旧的不需要的规则源。</p>
<h2>集群限流客户端</h2>
<p>要想使用集群限流功能，必须引入集群限流 client 相关依赖：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-cluster-client-default<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>用户可以通过 API 将当前模式置为客户端模式：</p>
<pre><code class="language-bash">http://&lt;ip&gt;:&lt;port&gt;/setClusterMode?mode=&lt;xxx&gt;
</code></pre>
<p>其中 mode 为 0 代表 client，1 代表 server。设置成功后，若已有客户端的配置，集群限流客户端将会开启并连接远程的 token server。我们可以在 <code>sentinel-record.log</code> 日志中查看连接的相关日志。</p>
<p>若集群限流客户端未进行配置，则用户需要对客户端进行基本的配置，比如指定集群限流 token server。我们提供了 API 进行配置：</p>
<pre><code class="language-bash">http://&lt;ip&gt;:&lt;port&gt;/cluster/client/modifyConfig?data=&lt;config&gt;
</code></pre>
<p>其中 data 是 JSON 格式的 <code>ClusterClientConfig</code>，对应的配置项：</p>
<ul>
<li><code>serverHost</code>: token server host</li>
<li><code>serverPort</code>: token server 端口</li>
<li><code>requestTimeout</code>: 请求的超时时间（默认为 20 ms）</li>
</ul>
<p>当然也可以通过动态配置源进行配置。我们可以通过 <code>ClusterClientConfigManager</code> 的 <code>register2Property</code> 方法注册动态配置源。配置源注册的相关逻辑可以置于 <code>InitFunc</code> 实现类中，并通过 SPI 注册，在 Sentinel 初始化时即可自动进行配置源加载监听。</p>
<p>若用户未引入集群限流 client 相关依赖，或者 client 未开启/连接失败/通信失败，则对于开启了集群模式的规则：</p>
<ul>
<li>集群热点限流默认直接通过</li>
<li>普通集群限流会退化到 local 模式的限流，即在本地按照单机阈值执行限流检查</li>
</ul>
<p>当 token client 与 server 之间的连接意外断开时，token client 会不断进行重试，每次重试的间隔时间以 <code>n * 2000 ms</code> 的形式递增。</p>
<h2>集群限流服务端</h2>
<p>要想使用集群限流服务端，必须引入集群限流 server 相关依赖：</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-cluster-server-default<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3>启动方式</h3>
<p>Sentinel 集群限流服务端有两种启动方式：</p>
<ul>
<li>独立模式（Alone），即作为独立的 token server 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 Global Rate Limiter 给集群提供流控服务。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/9434884/50463606-c3d26c00-09c7-11e9-8373-1c27e2408f8b.png" alt="image"></p>
<ul>
<li>嵌入模式（Embedded），即作为内置的 token server 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，token server 和 client 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 token server 的总 QPS，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/9434884/50463600-b7e6aa00-09c7-11e9-9580-6919f0d0a8a4.png" alt="image"></p>
<p>我们提供了 API 用于在 embedded 模式下转换集群流控身份：</p>
<pre><code class="language-bash">http://&lt;ip&gt;:&lt;port&gt;/setClusterMode?mode=&lt;xxx&gt;
</code></pre>
<p>其中 mode 为 <code>0</code> 代表 client，<code>1</code> 代表 server，<code>-1</code> 代表关闭。注意应用端需要引入集群限流客户端或服务端的相应依赖。</p>
<p>在独立模式下，我们可以直接创建对应的 <code>ClusterTokenServer</code> 实例并在 main 函数中通过 <code>start</code> 方法启动 Token Server。</p>
<h3>规则配置</h3>
<p>见前面“规则配置”相关内容。</p>
<h3>属性配置</h3>
<p>我们推荐给集群限流服务端注册动态配置源来动态地进行配置。配置类型有以下几种：</p>
<ul>
<li>namespace set: 集群限流服务端服务的作用域（命名空间），可以设置为自己服务的应用名。集群限流 client 在连接到 token server 后会上报自己的命名空间（默认为 <code>project.name</code> 配置的应用名），token server 会根据上报的命名空间名称统计连接数。</li>
<li>transport config: 集群限流服务端通信相关配置，如 server port</li>
<li>flow config: 集群限流服务端限流相关配置，如滑动窗口统计时长、格子数目、最大允许总 QPS等</li>
</ul>
<p>我们可以通过 <code>ClusterServerConfigManager</code> 的各个 <code>registerXxxProperty</code> 方法来注册相关的配置源。</p>
<p>从 1.4.1 版本开始，Sentinel 支持给 token server 配置最大允许的总 QPS（<code>maxAllowedQps</code>），来对 token server 的资源使用进行限制，防止在嵌入模式下影响应用本身。</p>
<h2>集群限流控制台</h2>
<p>参见 <a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%88%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%E7%AE%A1%E7%90%86%EF%BC%89">Sentinel 控制台（集群流控管理）</a>。</p>
<h2>扩展接口设计</h2>
<h3>整体扩展架构</h3>
<p><img src="https://user-images.githubusercontent.com/9434884/49844934-b03bd880-fdff-11e8-838e-6299ee24ff08.png" alt="overview-arch"></p>
<h3>通用扩展接口</h3>
<p>以下通用接口位于 <code>sentinel-core</code> 中：</p>
<ul>
<li><code>TokenService</code>: 集群限流功能接口，server / client 均可复用</li>
<li><code>ClusterTokenClient</code>: 集群限流功能客户端</li>
<li><code>ClusterTokenServer</code>: 集群限流服务端接口</li>
<li><code>EmbeddedClusterTokenServer</code>: 集群限流服务端接口（embedded 模式）</li>
</ul>
<p>以下通用接口位于 <code>sentinel-cluster-common-default</code>:</p>
<ul>
<li><code>EntityWriter</code></li>
<li><code>EntityDecoder</code></li>
</ul>
<h3>Client 扩展接口</h3>
<p>集群流控 Client 端通信相关扩展接口：</p>
<ul>
<li><code>ClusterTransportClient</code>：集群限流通信客户端</li>
<li><code>RequestEntityWriter</code></li>
<li><code>ResponseEntityDecoder</code></li>
</ul>
<h3>Server 扩展接口</h3>
<p>集群流控 Server 端通信相关扩展接口：</p>
<ul>
<li><code>ResponseEntityWriter</code></li>
<li><code>RequestEntityDecoder</code></li>
</ul>
<p>集群流控 Server 端请求处理扩展接口：</p>
<ul>
<li><code>RequestProcessor</code>: 请求处理接口 (request -&gt; response)</li>
</ul>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/sentinel_gray.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>Sentinel is an open-source project under Apache License 2.0.</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/introduction.html" target="_self">概览</a></dd><dd><a href="/zh-cn/docs/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/contribution/contribution-guideline.html" target="_self">开发者指南</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018 - 2019 The Sentinel Authors | An Alibaba Middleware (Aliware) Project</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>