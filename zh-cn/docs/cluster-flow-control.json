{
  "filename": "cluster-flow-control.md",
  "__html": "<h1>集群流量控制</h1>\n<h2>目录</h2>\n<ul>\n<li><a href=\"#%E4%BB%8B%E7%BB%8D\">集群流控介绍</a></li>\n<li><a href=\"#%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%E8%A7%84%E5%88%99\">集群流控规则配置</a></li>\n<li><a href=\"#%E7%A4%BA%E4%BE%8B\">集群流控示例</a></li>\n<li><a href=\"#%E9%9B%86%E7%BE%A4%E9%99%90%E6%B5%81%E6%8E%A7%E5%88%B6%E5%8F%B0\">集群流控管理（控制台）</a></li>\n<li><a href=\"https://github.com/alibaba/Sentinel/wiki/Envoy-RLS-Token-Server\">Envoy RLS token server</a></li>\n</ul>\n<h2>介绍</h2>\n<p>为什么要使用集群流控呢？假设我们希望给某个用户限制调用某个 API 的总 QPS 为 50，但机器数可能很多（比如有 100 台）。这时候我们很自然地就想到，找一个 server 来专门来统计总的调用量，其它的实例都与这台 server 通信来判断是否可以调用。这就是最基础的集群流控的方式。</p>\n<p>另外集群流控还可以解决流量不均匀导致总体限流效果不佳的问题。假设集群中有 10 台机器，我们给每台机器设置单机限流阈值为 10 QPS，理想情况下整个集群的限流阈值就为 100 QPS。不过实际情况下流量到每台机器可能会不均匀，会导致总量没有到的情况下某些机器就开始限流。因此仅靠单机维度去限制的话会无法精确地限制总体流量。而集群流控可以精确地控制整个集群的调用总量，结合单机限流兜底，可以更好地发挥流量控制的效果。</p>\n<p>集群流控中共有两种身份：</p>\n<ul>\n<li>Token Client：集群流控客户端，用于向所属 Token Server 通信请求 token。集群限流服务端会返回给客户端结果，决定是否限流。</li>\n<li>Token Server：即集群流控服务端，处理来自 Token Client 的请求，根据配置的集群规则判断是否应该发放 token（是否允许通过）。</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/65305357-8f39bc80-dbb5-11e9-96d6-d1111fc365a9.png\" alt=\"image\"></p>\n<h2>模块结构</h2>\n<p>Sentinel 1.4.0 开始引入了集群流控模块，主要包含以下几部分：</p>\n<ul>\n<li><code>sentinel-cluster-common-default</code>: 公共模块，包含公共接口和实体</li>\n<li><code>sentinel-cluster-client-default</code>: 默认集群流控 client 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展</li>\n<li><code>sentinel-cluster-server-default</code>: 默认集群流控 server 模块，使用 Netty 进行通信，提供接口方便序列化协议扩展；同时提供扩展接口对接规则判断的具体实现（<code>TokenService</code>），默认实现是复用 <code>sentinel-core</code> 的相关逻辑</li>\n</ul>\n<blockquote>\n<p>注意：集群流控模块要求 JDK 版本最低为 1.7。</p>\n</blockquote>\n<h2>集群流控规则</h2>\n<h3>规则</h3>\n<p><code>FlowRule</code> 添加了两个字段用于集群限流相关配置：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> clusterMode; <span class=\"hljs-comment\">// 标识是否为集群限流配置</span>\n<span class=\"hljs-keyword\">private</span> ClusterFlowConfig clusterConfig; <span class=\"hljs-comment\">// 集群限流相关配置项</span>\n</code></pre>\n<p>其中 用一个专门的 <code>ClusterFlowConfig</code> 代表集群限流相关配置项，以与现有规则配置项分开：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 全局唯一的规则 ID，由集群限流管控端分配.</span>\n<span class=\"hljs-keyword\">private</span> Long flowId;\n\n<span class=\"hljs-comment\">// 阈值模式，默认（0）为单机均摊，1 为全局阈值.</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> thresholdType = ClusterRuleConstant.FLOW_THRESHOLD_AVG_LOCAL;\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> strategy = ClusterRuleConstant.FLOW_CLUSTER_STRATEGY_NORMAL;\n\n<span class=\"hljs-comment\">// 在 client 连接失败或通信失败时，是否退化到本地的限流模式</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> fallbackToLocalWhenFail = <span class=\"hljs-keyword\">true</span>;\n</code></pre>\n<ul>\n<li><code>flowId</code> 代表全局唯一的规则 ID，Sentinel 集群限流服务端通过此 ID 来区分各个规则，因此<strong>务必保持全局唯一</strong>。一般 flowId 由统一的管控端进行分配，或写入至 DB 时生成。</li>\n<li><code>thresholdType</code> 代表集群限流阈值模式。其中<strong>单机均摊模式</strong>下配置的阈值等同于单机能够承受的限额，token server 会根据客户端对应的 namespace（默认为 <code>project.name</code> 定义的应用名）下的连接数来计算总的阈值（比如独立模式下有 3 个 client 连接到了 token server，然后配的单机均摊阈值为 10，则计算出的集群总量就为 30）；而全局模式下配置的阈值等同于<strong>整个集群的总阈值</strong>。</li>\n</ul>\n<p><code>ParamFlowRule</code> 热点参数限流相关的集群配置与 <code>FlowRule</code> 相似。</p>\n<h3>配置方式</h3>\n<p>在集群流控的场景下，我们推荐使用动态规则源来动态地管理规则。</p>\n<p>对于客户端，我们可以按照<a href=\"https://github.com/alibaba/Sentinel/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%99%E6%89%A9%E5%B1%95\">原有的方式</a>来向 <code>FlowRuleManager</code> 和 <code>ParamFlowRuleManager</code> 注册动态规则源，例如：</p>\n<pre><code class=\"language-java\">ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource = <span class=\"hljs-keyword\">new</span> NacosDataSource&lt;&gt;(remoteAddress, groupId, dataId, parser);\nFlowRuleManager.register2Property(flowRuleDataSource.getProperty());\n</code></pre>\n<p>对于集群流控 token server，由于集群限流服务端有作用域（namespace）的概念，因此我们需要注册一个自动根据 namespace 生成动态规则源的 PropertySupplier:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// Supplier 类型：接受 namespace，返回生成的动态规则源，类型为 SentinelProperty&lt;List&lt;FlowRule&gt;&gt;</span>\n<span class=\"hljs-comment\">// ClusterFlowRuleManager 针对集群限流规则，ClusterParamFlowRuleManager 针对集群热点规则，配置方式类似</span>\nClusterFlowRuleManager.setPropertySupplier(namespace -&gt; {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SomeDataSource(namespace).getProperty();\n});\n</code></pre>\n<p>然后每当集群限流服务端 namespace set 产生变更时，Sentinel 会自动针对新加入的 namespace 生成动态规则源并进行自动监听，并删除旧的不需要的规则源。</p>\n<h2>集群限流客户端</h2>\n<p>要想使用集群限流功能，必须引入集群限流 client 相关依赖：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-cluster-client-default<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.8.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>用户可以通过 API 将当前模式置为客户端模式：</p>\n<pre><code class=\"language-bash\">http://&lt;ip&gt;:&lt;port&gt;/setClusterMode?mode=&lt;xxx&gt;\n</code></pre>\n<p>其中 mode 为 0 代表 client，1 代表 server。设置成功后，若已有客户端的配置，集群限流客户端将会开启并连接远程的 token server。我们可以在 <code>sentinel-record.log</code> 日志中查看连接的相关日志。</p>\n<p>若集群限流客户端未进行配置，则用户需要对客户端进行基本的配置，比如指定集群限流 token server。我们提供了 API 进行配置：</p>\n<pre><code class=\"language-bash\">http://&lt;ip&gt;:&lt;port&gt;/cluster/client/modifyConfig?data=&lt;config&gt;\n</code></pre>\n<p>其中 data 是 JSON 格式的 <code>ClusterClientConfig</code>，对应的配置项：</p>\n<ul>\n<li><code>serverHost</code>: token server host</li>\n<li><code>serverPort</code>: token server 端口</li>\n<li><code>requestTimeout</code>: 请求的超时时间（默认为 20 ms）</li>\n</ul>\n<p>当然也可以通过动态配置源进行配置。我们可以通过 <code>ClusterClientConfigManager</code> 的 <code>register2Property</code> 方法注册动态配置源。配置源注册的相关逻辑可以置于 <code>InitFunc</code> 实现类中，并通过 SPI 注册，在 Sentinel 初始化时即可自动进行配置源加载监听。</p>\n<p>若用户未引入集群限流 client 相关依赖，或者 client 未开启/连接失败/通信失败，则对于开启了集群模式的规则：</p>\n<ul>\n<li>集群热点限流默认直接通过</li>\n<li>普通集群限流会退化到 local 模式的限流，即在本地按照单机阈值执行限流检查</li>\n</ul>\n<p>当 token client 与 server 之间的连接意外断开时，token client 会不断进行重试，每次重试的间隔时间以 <code>n * 2000 ms</code> 的形式递增。</p>\n<h2>集群限流服务端</h2>\n<p>要想使用集群限流服务端，必须引入集群限流 server 相关依赖：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-cluster-server-default<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.8.3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h3>启动方式</h3>\n<p>Sentinel 集群限流服务端有两种启动方式：</p>\n<ul>\n<li>独立模式（Alone），即作为独立的 token server 进程启动，独立部署，隔离性好，但是需要额外的部署操作。独立模式适合作为 Global Rate Limiter 给集群提供流控服务。</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/50463606-c3d26c00-09c7-11e9-8373-1c27e2408f8b.png\" alt=\"image\"></p>\n<ul>\n<li>嵌入模式（Embedded），即作为内置的 token server 与服务在同一进程中启动。在此模式下，集群中各个实例都是对等的，token server 和 client 可以随时进行转变，因此无需单独部署，灵活性比较好。但是隔离性不佳，需要限制 token server 的总 QPS，防止影响应用本身。嵌入模式适合某个应用集群内部的流控。</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/50463600-b7e6aa00-09c7-11e9-9580-6919f0d0a8a4.png\" alt=\"image\"></p>\n<p>我们提供了 API 用于在 embedded 模式下转换集群流控身份：</p>\n<pre><code class=\"language-bash\">http://&lt;ip&gt;:&lt;port&gt;/setClusterMode?mode=&lt;xxx&gt;\n</code></pre>\n<p>其中 mode 为 <code>0</code> 代表 client，<code>1</code> 代表 server，<code>-1</code> 代表关闭。注意应用端需要引入集群限流客户端或服务端的相应依赖。</p>\n<p>在独立模式下，我们可以直接创建对应的 <code>ClusterTokenServer</code> 实例并在 main 函数中通过 <code>start</code> 方法启动 Token Server。</p>\n<h3>规则配置</h3>\n<p>见前面“规则配置”相关内容。</p>\n<h3>属性配置</h3>\n<p>我们推荐给集群限流服务端注册动态配置源来动态地进行配置。配置类型有以下几种：</p>\n<ul>\n<li>namespace set: 集群限流服务端服务的作用域（命名空间），可以设置为自己服务的应用名。集群限流 client 在连接到 token server 后会上报自己的命名空间（默认为 <code>project.name</code> 配置的应用名），token server 会根据上报的命名空间名称统计连接数。</li>\n<li>transport config: 集群限流服务端通信相关配置，如 server port</li>\n<li>flow config: 集群限流服务端限流相关配置，如滑动窗口统计时长、格子数目、最大允许总 QPS等</li>\n</ul>\n<p>我们可以通过 <code>ClusterServerConfigManager</code> 的各个 <code>registerXxxProperty</code> 方法来注册相关的配置源。</p>\n<p>从 1.4.1 版本开始，Sentinel 支持给 token server 配置最大允许的总 QPS（<code>maxAllowedQps</code>），来对 token server 的资源使用进行限制，防止在嵌入模式下影响应用本身。</p>\n<h2>Token Server 分配配置</h2>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/58071181-60dbae80-7bce-11e9-9dc8-8e27e2161b0d.png\" alt=\"image\"></p>\n<h2>示例</h2>\n<p>sentinel-demo-cluster 提供了嵌入模式和独立模式的示例：</p>\n<ul>\n<li><a href=\"https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-cluster/sentinel-demo-cluster-server-alone/src/main/java/com/alibaba/csp/sentinel/demo/cluster/ClusterServerDemo.java\">sentinel-demo-cluster-server-alone</a>：独立模式 Demo</li>\n<li><a href=\"https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-cluster/sentinel-demo-cluster-embedded\">sentinel-demo-cluster-embedded</a>：嵌入模式 Demo，以 Web 应用为示例，可以启动多个实例分别作为 Token Server 和 Token Client。数据源的相关配置可以参考 <a href=\"https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-cluster/sentinel-demo-cluster-embedded/src/main/java/com/alibaba/csp/sentinel/demo/cluster/init/DemoClusterInitFunc.java\">DemoClusterInitFunc</a>。</li>\n</ul>\n<blockquote>\n<p>注意：若在本地启动多个 Demo 示例，需要加上 <code>-Dcsp.sentinel.log.use.pid=true</code> 参数，否则控制台显示监控会不准确。</p>\n</blockquote>\n<h2>集群限流控制台</h2>\n<p>使用集群限流功能需要对 Sentinel 控制台进行相关的改造，推送规则时直接推送至配置中心，接入端引入 push 模式的动态数据源。可以参考 <a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%88%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7%E7%AE%A1%E7%90%86%EF%BC%89\">Sentinel 控制台（集群流控管理文档）</a>。</p>\n<p>同时云上版本 <a href=\"https://help.aliyun.com/document_detail/174871.html\">AHAS Sentinel</a> 提供<strong>开箱即用的全自动托管集群流控能力</strong>，无需手动指定/分配 token server 以及管理连接状态，同时支持分钟小时级别流控、大流量低延时场景流控场景，同时支持 Istio/Envoy 场景的 Mesh 流控能力。</p>\n<h2>扩展接口设计</h2>\n<h3>整体扩展架构</h3>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/49844934-b03bd880-fdff-11e8-838e-6299ee24ff08.png\" alt=\"overview-arch\"></p>\n<h3>通用扩展接口</h3>\n<p>以下通用接口位于 <code>sentinel-core</code> 中：</p>\n<ul>\n<li><code>TokenService</code>: 集群限流功能接口，server / client 均可复用</li>\n<li><code>ClusterTokenClient</code>: 集群限流功能客户端</li>\n<li><code>ClusterTokenServer</code>: 集群限流服务端接口</li>\n<li><code>EmbeddedClusterTokenServer</code>: 集群限流服务端接口（embedded 模式）</li>\n</ul>\n<p>以下通用接口位于 <code>sentinel-cluster-common-default</code>:</p>\n<ul>\n<li><code>EntityWriter</code></li>\n<li><code>EntityDecoder</code></li>\n</ul>\n<h3>Client 扩展接口</h3>\n<p>集群流控 Client 端通信相关扩展接口：</p>\n<ul>\n<li><code>ClusterTransportClient</code>：集群限流通信客户端</li>\n<li><code>RequestEntityWriter</code></li>\n<li><code>ResponseEntityDecoder</code></li>\n</ul>\n<h3>Server 扩展接口</h3>\n<p>集群流控 Server 端通信相关扩展接口：</p>\n<ul>\n<li><code>ResponseEntityWriter</code></li>\n<li><code>RequestEntityDecoder</code></li>\n</ul>\n<p>集群流控 Server 端请求处理扩展接口：</p>\n<ul>\n<li><code>RequestProcessor</code>: 请求处理接口 (request -&gt; response)</li>\n</ul>\n"
}