{
  "filename": "basic-api.md",
  "__html": "<h1>基本使用</h1>\n<p>使用 Sentinel 主要分为以下几步：</p>\n<ol>\n<li>对 Sentinel 进行相关配置并进行初始化</li>\n<li>埋点（定义资源）</li>\n<li>配置规则</li>\n</ol>\n<h2>通用配置及初始化</h2>\n<p>使用 Sentinel 时需要在应用启动时对 Sentinel 进行相关配置并触发初始化。<code>api</code> 包下提供如下函数：</p>\n<ul>\n<li><code>InitDefault()</code>：从环境变量中读取相应配置来初始化 Sentinel，若环境变量不存在则使用默认值。</li>\n<li><code>InitWithConfigFile(configPath string)</code>：从给定的 YAML 文件中读取相应配置来初始化 Sentinel。日志目录配置会从环境变量读取或采用默认路径（<code>~/logs/csp</code>）。</li>\n</ul>\n<p>通用配置项加载策略和配置项请参考 <a href=\"https://github.com/alibaba/sentinel-golang/wiki/%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%E9%A1%B9\">通用配置项文档</a></p>\n<p>示例代码：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">import</span> (\n\tsentinel <span class=\"hljs-string\">\"github.com/alibaba/sentinel-golang/api\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">initSentinel</span><span class=\"hljs-params\">()</span></span> {\n\terr := sentinel.InitWithLogDir(confPath, logDir)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-comment\">// 初始化 Sentinel 失败</span>\n\t}\n}\n</code></pre>\n<p><strong>注意</strong>：必须成功调用 Sentinel 的初始化函数以后再调用埋点 API。</p>\n<h2>埋点</h2>\n<p>使用 Sentinel 的 Entry API 将业务逻辑封装起来，这一步称为“埋点”。每个埋点都有一个资源名称（resource），代表触发了这个资源的调用或访问。</p>\n<p>埋点 API 位于 <code>api</code> 包中：</p>\n<ul>\n<li><code>Entry(resource string, opts ...Option) (*base.SentinelEntry, *base.BlockError)</code></li>\n</ul>\n<p>其中 <code>resource</code> 代表埋点资源名，<code>opts</code> 代表埋点配置。目前支持以下埋点配置：</p>\n<ul>\n<li><code>WithTrafficType(entryType base.TrafficType)</code>：标记该埋点资源的流量类型，其中 Inbound 代表入口流量，Outbound 代表出口流量。若不指定，默认为 Outbound。</li>\n<li><code>WithResourceType(resourceType base.ResourceType)</code>：标记该埋点资源的分类。</li>\n<li><code>WithAcquireCount(acquireCount uint32)</code>：标记每次触发该埋点计为几次调用（可以理解为 batch count）。若不指定，默认为 1。</li>\n<li><code>WithArgs(args ...interface{})</code>：埋点携带的参数列表，为热点参数统计预留。</li>\n</ul>\n<p>埋点 API 示例：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">import</span> (\n\tsentinel <span class=\"hljs-string\">\"github.com/alibaba/sentinel-golang/api\"</span>\n)\n\n<span class=\"hljs-comment\">// Entry 方法用于埋点</span>\ne, b := sentinel.Entry(<span class=\"hljs-string\">\"your-resource-name\"</span>, sentinel.WithTrafficType(base.Inbound))\n<span class=\"hljs-keyword\">if</span> b != <span class=\"hljs-literal\">nil</span> {\n\t<span class=\"hljs-comment\">// 请求被流控，可以从 BlockError 中获取限流详情</span>\n} <span class=\"hljs-keyword\">else</span> {\n\t<span class=\"hljs-comment\">// 请求可以通过，在此处编写您的业务逻辑</span>\n\t<span class=\"hljs-comment\">// 务必保证业务逻辑结束后 Exit</span>\n\te.Exit()\n}\n</code></pre>\n<p>若该次调用被拒绝，则 Entry API 会返回 BlockError 代表被 Sentinel 限流。BlockError 提供了限流原因以及触发的规则等信息，可以方便开发者获取相关信息进行记录和处理。</p>\n<h2>规则配置</h2>\n<h3>动态数据源</h3>\n<p>（规划中）Sentinel 提供动态数据源接口进行扩展，用户可以通过动态文件或 etcd 等配置中心来动态地配置规则。</p>\n<h3>硬编码方式</h3>\n<p>Sentinel 也支持原始的硬编码方式加载规则，可以通过各个模块的 <code>LoadRules(rules)</code> 方法加载规则。以流控规则为例：</p>\n<pre><code class=\"language-go\">_, err := flow.LoadRules([]*flow.FlowRule{\n\t{\n\t\tID:                <span class=\"hljs-number\">666</span>,\n\t\tResource:          <span class=\"hljs-string\">\"some-resource\"</span>,\n\t\tMetricType:        flow.QPS,\n\t\tCount:             <span class=\"hljs-number\">10</span>,\n\t\tControlBehavior:   flow.Reject,\n\t},\n})\n<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t<span class=\"hljs-comment\">// 加载规则失败，进行相关处理</span>\n}\n</code></pre>\n"
}