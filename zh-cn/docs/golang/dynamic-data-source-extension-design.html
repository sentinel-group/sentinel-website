<!DOCTYPE html>
<html lang="en">

<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163094446-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-163094446-1');
	</script>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="dynamic-data-source-extension-design" />
	<meta name="description" content="dynamic-data-source-extension-design" />
	<!-- 网页标签标题 -->
	<title>dynamic-data-source-extension-design</title>
	<link rel="shortcut icon" href="/img/sentinel.ico"/>
	<link rel="stylesheet" href="/build/documentation.css" />
</head>
<body>
	<div id="root"><div class="documentation-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/sentinel_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/system/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/docs/introduction.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html" target="_self">开发者</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li><li class="menu-item menu-item-normal"><a href="https://www.aliyun.com/product/ahas" target="_self">企业版 Sentinel</a><img class="menu-img" src="https://img.alicdn.com/tfs/TB1esl_m.T1gK0jSZFrXXcNCXXa-200-200.png"/></li></ul></div></div></header><div class="bar"><div class="bar-body"><img src="/img/system/docs.png" class="front-img"/><span>文档</span><img src="/img/system/docs.png" class="back-img"/></div></div><section class="content-section"><div class="sidemenu"><div class="sidemenu-toggle"><img src="https://img.alicdn.com/tfs/TB1E6apXHGYBuNjy0FoXXciBFXa-200-200.png"/></div><ul><li class="menu-item menu-item-level-1"><span>用户文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>入门<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/introduction.html" target="_self">Sentinel 介绍</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/quick-start.html" target="_self">快速开始</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/basic-implementation.html" target="_self">基本原理</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/faq.html" target="_self">FAQ</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>使用文档<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/basic-api-resource-rule.html" target="_self">基本使用（资源与规则）</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/flow-control.html" target="_self">流量控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/circuit-breaking.html" target="_self">熔断降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/system-adaptive-protection.html" target="_self">系统自适应保护</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/cluster-flow-control.html" target="_self">集群流量控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/api-gateway-flow-control.html" target="_self">网关流量控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/parameter-flow-control.html" target="_self">热点参数限流</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/origin-authority-control.html" target="_self">来源访问控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/annotation-support.html" target="_self">注解支持</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/dynamic-rule-configuration.html" target="_self">动态规则扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/logs.html" target="_self">日志</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/metrics.html" target="_self">实时监控</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/general-configuration.html" target="_self">启动配置项</a></li></ul></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/dashboard.html" target="_self">Sentinel 控制台</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/open-source-framework-integrations.html" target="_self">开源框架适配</a></li><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/polyglot-support.html" target="_self">多语言支持</a></li></ul></li><li class="menu-item menu-item-level-1"><span>多语言文档</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><span>Sentinel Go<img style="transform:rotate(-90deg)" class="menu-toggle" src="/img/system/arrow_down.png"/></span><ul><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/basic-api-usage.html" target="_self">基本 API 使用指南</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/flow-control.html" target="_self">流量控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/circuit-breaking.html" target="_self">熔断降级</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/concurrency-limiting-isolation.html" target="_self">并发隔离控制</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/system-adaptive-protection.html" target="_self">系统自适应保护</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/hotspot-param-flow-control.html" target="_self">热点参数流控</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/dynamic-data-source-usage.html" target="_self">动态规则扩展</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/general-configuration.html" target="_self">通用配置</a></li><li class="menu-item menu-item-level-3"><a href="/zh-cn/docs/golang/logging.html" target="_self">日志</a></li></ul></li></ul></li><li class="menu-item menu-item-level-1"><span>贡献手册</span><ul><li style="height:36px;overflow:hidden" class="menu-item menu-item-level-2"><a href="/zh-cn/docs/contribution/contribution-guideline.html" target="_self">开源贡献指南</a></li></ul></li></ul></div><div class="doc-content markdown-body"><h1>动态数据源扩展</h1>
<p>这个 Wiki 主要描述 <a href="https://github.com/alibaba/sentinel-golang">sentinel-golang</a> 的动态数据源扩展的设计。目前 Sentinel 内部的限流、熔断等策略都是基于规则来实现的，提供动态数据源扩展的目的，就是希望将规则数据或则其余的 properties 的更新操作通过一些配置中心中间件(比如 etcd,conful,nacos-go 等等)来实现动态更新。整体数据流的pipeline大概就是：Sentinel board 或则是其余的 Config center dashboard --&gt; 配置中心中间件 --&gt; sentinel， 从而实现 properties 的动态更新。</p>
<h2>Overall</h2>
<p>动态数据源扩展的整体架构和 Java 版本是一样的，可以参考下图所示架构图：</p>
<p><img src="https://user-images.githubusercontent.com/9434884/45406233-645e8380-b698-11e8-8199-0c917403238f.png" alt=""></p>
<p>整体的设计分为两大块：property的抽象和DataSource数据源的抽象。</p>
<ol>
<li>Property的抽象作为DataSource的下游，负责具体property的处理，将最新的property更新到下游的组件(比如流控规则、限流规则、配置模块等)。</li>
<li>DataSource的抽象主要是负责建立与配置中心中间件建立长连接，基于类似于Watcher的监听机制来监听具体property的变化，并将property变化通过Property的抽象处理。</li>
</ol>
<h2>Property的设计</h2>
<p>Property的抽象通过接口 <code>PropertyHandler</code> 接口来定义，PropertyHandler的职责边界是：处理输入的property字节，并将最新的property更新到下游相关联的核心组件。</p>
<pre><code class="language-go"><span class="hljs-keyword">type</span> PropertyHandler <span class="hljs-keyword">interface</span> {
	<span class="hljs-comment">// check whether the current src is consistent with last update property</span>
	isPropertyConsistent(src <span class="hljs-keyword">interface</span>{}) <span class="hljs-keyword">bool</span>
	<span class="hljs-comment">// handle the current property</span>
	Handle(src []<span class="hljs-keyword">byte</span>) error
}
</code></pre>
<p><code>PropertyHandler</code> 的定义非常简单，只包含两个函数：</p>
<ol>
<li><code>isPropertyConsistent</code> 函数用于判断当前更新的 property 是否和上次更新的一样，如果一样就不做更新，类似于一个缓存过滤机制。</li>
<li><code>Handle</code> 函数则负责具体的 property 处理逻辑，包括将字节数组转换成实际的 property ，并将该 property 更新到下游相关联的核心组件。</li>
</ol>
<p>Sentinel 提供了 <code>PropertyHandler</code> 的一个默认的实现：<code>DefaultPropertyHandler</code>。</p>
<pre><code class="language-go"><span class="hljs-keyword">type</span> DefaultPropertyHandler <span class="hljs-keyword">struct</span> {
	lastUpdateProperty <span class="hljs-keyword">interface</span>{}

	converter PropertyConverter
	updater   PropertyUpdater
}
</code></pre>
<p>这里的一个DefaultPropertyHandler实例将用于处理一个 property type。 属性<code>lastUpdateProperty</code> 用于缓存上次更新的property，用于过滤无效property。 此外还包含两个函数属性, 下面先看定义：</p>
<pre><code class="language-go"><span class="hljs-comment">// PropertyConverter func is to converter source message bytes to the specific property.</span>
<span class="hljs-comment">// the first  return value: is the real property;</span>
<span class="hljs-comment">// the second return value: return nil if succeed to convert src, if not return the detailed error when convert src.</span>
<span class="hljs-comment">// if src is nil or len(src)==0, the return value is (nil,nil)</span>
<span class="hljs-keyword">type</span> PropertyConverter <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(src []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>{}, error)</span>

// <span class="hljs-title">PropertyUpdater</span> <span class="hljs-title">func</span> <span class="hljs-title">is</span> <span class="hljs-title">to</span> <span class="hljs-title">update</span> <span class="hljs-title">the</span> <span class="hljs-title">specific</span> <span class="hljs-title">properties</span> <span class="hljs-title">to</span> <span class="hljs-title">downstream</span>.
// <span class="hljs-title">return</span> <span class="hljs-title">nil</span> <span class="hljs-title">if</span> <span class="hljs-title">succeed</span> <span class="hljs-title">to</span> <span class="hljs-title">update</span>, <span class="hljs-title">if</span> <span class="hljs-title">not</span>, <span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">error</span>.
<span class="hljs-title">type</span> <span class="hljs-title">PropertyUpdater</span> <span class="hljs-title">func</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">error</span>
</span></code></pre>
<p>PropertyConverter：会将property的字节数组反序列化成具体的property类型。 具体的反序列化协议依据用户的实现，提供比较高的灵活性，Sentinel默认会提供一个json反序列化的实现，用户也可以根据自己的需求，自己实现自己的反序列化方式。</p>
<p>PropertyUpdater：会将具体的property类型数据，更新到相关联的下游的核心组件。比如 []FlowRule 类型的property会被更新到 flow module的flow manager里面。这里sentinel框架会提供所有支持的动态 property 的update函数的实现，用户对这个理论上来说是不感知的。</p>
<p>这里需要强调的是，每种动态property类型的PropertyConverter和PropertyUpdater是成对出现在<code>DefaultPropertyHandler</code>中的。</p>
<p><code>DefaultPropertyHandler</code> 具体的 <code>Handle</code> 函数的实现可以参考源码：</p>
<pre><code class="language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *DefaultPropertyHandler)</span> <span class="hljs-title">Handle</span><span class="hljs-params">(src []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> {
	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &amp;&amp; logger != <span class="hljs-literal">nil</span> {
			logger.Panicf(<span class="hljs-string">"Unexpected panic: %+v"</span>, errors.Errorf(<span class="hljs-string">"%+v"</span>, err))
		}
	}()
	<span class="hljs-comment">// convert to target property</span>
	realProperty, err := h.converter(src)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> err
	}
	isConsistent := h.isPropertyConsistent(realProperty)
	<span class="hljs-keyword">if</span> isConsistent {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	}
	<span class="hljs-keyword">return</span> h.updater(realProperty)
}
</code></pre>
<p>整体的workflow如下：</p>
<ol>
<li>调用converter将 []bytes 转成具体的property；</li>
<li>通过缓存过滤无效property；</li>
<li>更新实际的property到相关联的下游组件。</li>
</ol>
<p>针对Sentinel 现有组件可能的动态 property，Sentinel提供了一个 helper.go 的函数集，里面包含了一系列的 Converter 和 Updater。源码在：
<a href="https://github.com/alibaba/sentinel-golang/blob/master/ext/datasource/helper.go">helper.go</a>
helper.go里面的 <strong>xxxUpdater</strong> 是更新下游的标准函数；xxxConverter是默认提供的json协议的标准化converter，用户可以根据自己的实际业务需要，基于自己的协议实现自己的converter，只需要保证满足 <code>PropertyConverter</code> 函数的定义以及入参出参语义就OK。</p>
<h2>数据源抽象设计</h2>
<p>数据源的抽象通过接口 <code>Datasource</code> 来定义，一个<code>Datasource</code> 可能会有多个下游的property handler来处理。<code>Datasource</code>的职责就是负责建立与配置中心中间件建立长连接，基于类似于Watcher的监听机制监听具体property的变化，并将property变化通过下游的property handler来处理。下面是接口的定义：</p>
<pre><code class="language-go"><span class="hljs-comment">// The generic interface to describe the datasource</span>
<span class="hljs-comment">// Each DataSource instance listen in one property type.</span>
<span class="hljs-keyword">type</span> DataSource <span class="hljs-keyword">interface</span> {
	<span class="hljs-comment">// Add specified property handler in current datasource</span>
	AddPropertyHandler(h PropertyHandler)
	<span class="hljs-comment">// Remove specified property handler in current datasource</span>
	RemovePropertyHandler(h PropertyHandler)
	<span class="hljs-comment">// Read original data from the data source.</span>
	<span class="hljs-comment">// return source bytes if succeed to read, if not, return error when reading</span>
	ReadSource() ([]<span class="hljs-keyword">byte</span>, error)
	<span class="hljs-comment">// Initialize the datasource and load initial rules</span>
	<span class="hljs-comment">// start listener to listen on dynamic source</span>
	<span class="hljs-comment">// return error if initialize failed;</span>
	<span class="hljs-comment">// once initialized, listener should recover all panic and error.</span>
	Initialize() error
	<span class="hljs-comment">// Close the data source.</span>
	io.Closer
}
</code></pre>
<p>这里主要有两个函数需要介绍下：</p>
<ol>
<li>ReadSource：基于watcher机制，从watcher读取最新的property数据。</li>
<li>Initialize：这里需要创建property的watcher，并通过一个单独的goroutine来监听watcher上的事件并处理相应的事件。</li>
</ol>
<p>DataSource是一个非常抽象的接口，所有具体数据源扩展的实现都需要实现这个接口。Sentinel 封装了一些数据源通用的逻辑到 dataSource.Base里面，这里主要是与handlers相关的，具体代码可能参考：</p>
<pre><code class="language-go"><span class="hljs-keyword">type</span> Base <span class="hljs-keyword">struct</span> {
	handlers []PropertyHandler
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Base)</span> <span class="hljs-title">Handlers</span><span class="hljs-params">()</span> []<span class="hljs-title">PropertyHandler</span></span> {
	<span class="hljs-keyword">return</span> b.handlers
}

<span class="hljs-comment">// return idx if existed, else return -1</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Base)</span> <span class="hljs-title">indexOfHandler</span><span class="hljs-params">(h PropertyHandler)</span> <span class="hljs-title">int</span></span> {
	<span class="hljs-keyword">for</span> idx, handler := <span class="hljs-keyword">range</span> b.handlers {
		<span class="hljs-keyword">if</span> handler == h {
			<span class="hljs-keyword">return</span> idx
		}
	}
	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Base)</span> <span class="hljs-title">AddPropertyHandler</span><span class="hljs-params">(h PropertyHandler)</span></span> {
	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> || b.indexOfHandler(h) &gt;= <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span>
	}
	b.handlers = <span class="hljs-built_in">append</span>(b.handlers, h)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Base)</span> <span class="hljs-title">RemovePropertyHandler</span><span class="hljs-params">(h PropertyHandler)</span></span> {
	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span>
	}
	idx := b.indexOfHandler(h)
	<span class="hljs-keyword">if</span> idx &lt; <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span>
	}
	b.handlers = <span class="hljs-built_in">append</span>(b.handlers[:idx], b.handlers[idx+<span class="hljs-number">1</span>:]...)
}
</code></pre>
<p>主要包括一个DataSource相关的 handlers的定义以及相关增删。</p>
<h1>Example: refresh file datasource:</h1>
<p>为了方便开发者理解，Sentinel 提供了一个基于文件的数据源的example, 具体代码可以参考：<a href="https://github.com/alibaba/sentinel-golang/tree/master/ext/datasource/file">refreshable_file.go</a></p>
<h1>Use case</h1>
<h2>app instance复用etcd长连接的场景：</h2>
<p>etcd client 和 server 底层的数据交换是基于gRPC的，gRPC使用的是http2的长连接。所以比较期待的是每个应用的instance存在多个动态Property时候，能够复用一个长连接。</p>
<p>etcd client与Server保持长连接是基于 clientv3/client.go里面的<a href="https://github.com/etcd-io/etcd/blob/0eee733220fc766ff0d193d61d9124aa06493986/clientv3/client.go#L72">Client struct</a>。Sentinel期望不管用户在一个 APP instance上不管创建多少个动态 property 的数据源，都能够复用一个 etcd 的长连接。</p>
<p>下面提供了一个demo 伪代码实现：</p>
<pre><code class="language-go"><span class="hljs-keyword">type</span> DatasourceGenerator <span class="hljs-keyword">struct</span> {
	etcdv3Client *clientv3.Client
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDatasourceGenerator</span><span class="hljs-params">(config *clientv3.Config)</span> *<span class="hljs-title">DatasourceGenerator</span></span> {
	client, err := clientv3.New(*config)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		logging.GetDefaultLogger().Errorf(<span class="hljs-string">"Fail to instance clientv3 Client, err: %+v"</span>, err)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	}
	<span class="hljs-keyword">return</span> &amp;DatasourceGenerator{etcdv3Client: client}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *DatasourceGenerator)</span> <span class="hljs-title">Generate</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, handlers ...datasource.PropertyHandler)</span> <span class="hljs-params">(*Etcdv3DataSource, error)</span></span> {
	<span class="hljs-keyword">var</span> err error
	<span class="hljs-keyword">if</span> g.etcdv3Client == <span class="hljs-literal">nil</span> {
		err = errors.New(<span class="hljs-string">"The etcdv3 client is nil in DatasourceGenerator"</span>)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
	}
	ds := &amp;Etcdv3DataSource{
		client:      g.etcdv3Client,
		propertyKey: key,
	}
	<span class="hljs-keyword">for</span> _, h := <span class="hljs-keyword">range</span> handlers {
		ds.AddPropertyHandler(h)
	}
	<span class="hljs-keyword">return</span> ds, err
}
</code></pre>
<p>实际使用的demo：</p>
<pre><code class="language-go">etcdv3Gen := NewDatasourceGenerator()
<span class="hljs-keyword">if</span> etcdv3Gen == <span class="hljs-literal">nil</span> {
    logger.Errorf(<span class="hljs-string">"Fail to instance etcdv3 datasource generator."</span>)
    <span class="hljs-keyword">return</span>
}
ds1 := etcdv3Gen.Generate(key, handle...)
ds2 := etcdv3Gen.Generate(key, handle...)
ds3 := etcdv3Gen.Generate(key, handle...)
......
</code></pre>
<h2>一个动态property关联一个动态数据源场景</h2>
<p>Suppose现在property是system rules, property的下游也只有system manager。test code如下：</p>
<pre><code class="language-go">ds := NewFileDataSource(TestSystemRulesFile, NewSystemRulesHandler(SystemRulesJsonConverter))
err = ds.Initialize()
</code></pre>
<h2>一个动态property使用一个动态数据源，但是下游存在联动场景</h2>
<p>先介绍下联动场景的背景：在集群模式下，Server端维护了一个namespaceSet(这里namespace表示的是每一个client的unique描述)，这个namespaceSet property 通过动态数据源来维护，做动态更新。</p>
<p>集群模式下，client其实是一个非常轻的存在，所有的集群流控check实际上都是在Server端来做的，Server端维护了每一个client端的流控rules以及动态数据源。用伪代码来表示，Server端维护了一个map：namespace -&gt; datasource，这里map的value的每一个datasource表示一个client的流控规则的动态数据源，所以client的更新实际上是在Server端来做的。</p>
<p>这个时候有一个场景：假设Server端的 namespaceSet property 动态数据源做了一个update，更改了namespaceSet(也就是client端存在增删情况)，这时候Server端也需要做对应数据源的增删，也就是联动场景。</p>
<p>这种场景下，需要添加一个中间层，这个中间层的主要职责是维护 namespace -&gt; datasource 的map关系，并且根据上游 namespaceSet的动态更新，更新中间层的数据。</p>
<p>基于现有DataSource的设计，给出联动场景的伪代码：</p>
<pre><code class="language-go">namespacesDatasource := NewDatasource(key, handlers{NamespacesJsonConverter, NamespacesUpdater}...)
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NamespacesJsonConverter</span><span class="hljs-params">(src []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>{}, error)</span></span>{
    <span class="hljs-comment">// return namespaces string list.</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NamespacesUpdater</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">error</span></span> {
    <span class="hljs-comment">// Call ClusterDatasourceManager.LoadNamespaces()</span>
}


<span class="hljs-comment">// 中间层</span>
<span class="hljs-comment">// datasource generator</span>
<span class="hljs-keyword">type</span> Generator <span class="hljs-keyword">struct</span> {

}

<span class="hljs-keyword">type</span> ClusterDatasourceManager <span class="hljs-keyword">struct</span>{
    datasourceGenerator Generator
    <span class="hljs-comment">//namespace -&gt; Datasource</span>
    clientDatasource <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]datasource.Datasource
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadNamespaces</span><span class="hljs-params">(namespaces []<span class="hljs-keyword">string</span>)</span></span>{
    <span class="hljs-comment">//check diff between current namespaces and the keys of clientDatasource</span>
    <span class="hljs-comment">// call generator to generate new datasource.</span>
    <span class="hljs-comment">// thread safe to update clientDatasource</span>
}
--------------------------------------------------------------------
<span class="hljs-comment">// 集群流控规则manager</span>
<span class="hljs-keyword">type</span> ClusterFlowRuleManager <span class="hljs-keyword">struct</span> {
   <span class="hljs-comment">// namespace -&gt; rule list</span>
   clientRules <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]*FlowRule
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LoadNamespaceRules</span><span class="hljs-params">(namespace <span class="hljs-keyword">string</span>, rules []*flow.Rules)</span></span>{

}
</code></pre>
<h2>多个动态property type共享一个数据源</h2>
<p>假设现在存在多个property type: system rules, flow rules, circuit breaker rules. 期望通过一个动态compound property就能实现动态更新这三种类型的sub property。</p>
<p>假设 property schema 大概是这样：</p>
<pre><code class="language-json">{
    <span class="hljs-attr">"systemRules"</span>:{
    },
    <span class="hljs-attr">"flowRules"</span>:{
    },
    <span class="hljs-attr">"cbRules"</span>:{
    }
}
</code></pre>
<p>基于现有DataSource extension的design是可以实现的。用户需要创建三个数据源 systemRulesDS,flowRulesDS,cbRulesDS，伪代码如下：</p>
<pre><code class="language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SystemRulesConverter</span><span class="hljs-params">(src []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>{}, error)</span></span> {
    <span class="hljs-number">1.</span> Decode src to Property <span class="hljs-keyword">struct</span>
    <span class="hljs-number">2.</span> get systemRules related data
    <span class="hljs-number">3.</span> <span class="hljs-keyword">return</span> system Rule list.
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FlowRulesConverter</span><span class="hljs-params">(src []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>{}, error)</span></span> {
    <span class="hljs-number">1.</span> Decode src to Property <span class="hljs-keyword">struct</span>
    <span class="hljs-number">2.</span> get flowRules related data
    <span class="hljs-number">3.</span> <span class="hljs-keyword">return</span> flow Rule list.
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cbRulesConverter</span><span class="hljs-params">(src []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>{}, error)</span></span> {
    <span class="hljs-number">1.</span> Decode src to Property <span class="hljs-keyword">struct</span>
    <span class="hljs-number">2.</span> get cbRules related data
    <span class="hljs-number">3.</span> <span class="hljs-keyword">return</span> cb Rule list.
}

<span class="hljs-comment">// new system rules datasource</span>
systemRulesDS := NewDatasource(propertyLocation, NewDefaultPropertyHandler(SystemRulesConverter, SystemRulesUpdater));
<span class="hljs-comment">// new flow rules datasource</span>
flowRulesDS := NewDatasource(propertyLocation, NewDefaultPropertyHandler(FlowRulesConverter, FlowRulesUpdater));
<span class="hljs-comment">// new cb rules datasource</span>
cbRulesDS := NewDatasource(propertyLocation, NewDefaultPropertyHandler(CbRulesConverter, CbRulesUpdater));

systemRulesDS.Initialize()
flowRulesDS.Initialize()
cbRulesDS.Initialize()
</code></pre>
</div></section><footer class="footer-container"><div class="footer-body"><img src="/img/sentinel_gray.png"/><div class="cols-container"><div class="col col-12"><h3>Disclaimer</h3><p>Sentinel is an open-source project under Apache License 2.0.</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/introduction.html" target="_self">概览</a></dd><dd><a href="/zh-cn/docs/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/contribution/contribution-guideline.html" target="_self">开发者指南</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018 - 2020 The Sentinel Authors | An Alibaba Middleware (Aliware) Project</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/documentation.js"></script>
</body>
</html>